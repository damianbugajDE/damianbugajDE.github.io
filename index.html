<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MEGA Quiz: Programowanie Niskopoziomowe</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f2f5;
            color: #333;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        h1 {
            text-align: center;
            color: #1a237e;
            margin-bottom: 10px;
        }
        p.subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
        }
        .score-box {
            background: #fff;
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            margin-bottom: 20px;
            text-align: center;
            font-size: 1.2em;
            font-weight: bold;
            color: #2c3e50;
            position: sticky;
            top: 10px;
            z-index: 100;
            border: 1px solid #e1e4e8;
        }
        .question-card {
            background: #fff;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            margin-bottom: 20px;
            display: none; 
            border: 1px solid #e1e4e8;
        }
        .question-card.active {
            display: block;
            animation: fadeIn 0.3s ease-in;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .question-text {
            font-size: 1.2em;
            margin-bottom: 20px;
            font-weight: 600;
            line-height: 1.4;
        }
        .options {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .option-btn {
            padding: 15px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            background: #fff;
            cursor: pointer;
            text-align: left;
            transition: all 0.2s;
            font-size: 1em;
            color: #495057;
            font-weight: 500;
        }
        .option-btn:hover {
            background-color: #f8f9fa;
            border-color: #dee2e6;
        }
        .option-btn:active {
            transform: scale(0.99);
        }
        .correct {
            background-color: #d1e7dd !important;
            border-color: #badbcc !important;
            color: #0f5132 !important;
        }
        .incorrect {
            background-color: #f8d7da !important;
            border-color: #f5c6cb !important;
            color: #842029 !important;
        }
        .explanation {
            margin-top: 20px;
            padding: 15px;
            background-color: #e7f1ff;
            border-left: 5px solid #0d6efd;
            border-radius: 4px;
            font-size: 0.95em;
            display: none;
            line-height: 1.5;
        }
        button.next-btn {
            margin-top: 25px;
            padding: 12px 30px;
            background-color: #0d6efd;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.1em;
            display: none;
            float: right;
            transition: background 0.2s;
        }
        button.next-btn:hover {
            background-color: #0b5ed7;
        }
        .final-screen {
            text-align: center;
            display: none;
            padding: 40px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
        }
        .final-score {
            font-size: 3em;
            font-weight: bold;
            color: #0d6efd;
            margin: 20px 0;
        }
    </style>
</head>
<body>

    <h1>Programowanie Niskopoziomowe</h1>
    <p class="subtitle">Pena baza pyta ze zdj (v2.0)</p>
    
    <div class="score-box" id="scoreBox">
        Pytanie: <span id="currentQ">1</span>/<span id="totalQ">20</span> | Punkty: <span id="score">0</span>
    </div>

    <div id="quiz-container">
        </div>

    <div class="final-screen" id="finalScreen">
        <h2>Koniec egzaminu!</h2>
        <p>Tw贸j wynik kocowy:</p>
        <div class="final-score"><span id="finalScore">0</span> / <span id="finalTotal">0</span></div>
        <p id="feedbackText"></p>
        <button onclick="location.reload()" class="next-btn" style="display:inline-block; float:none;">Spr贸buj ponownie</button>
    </div>

<script>
    // Baza pyta zadeklarowana jako tablica obiekt贸w
    const questions = [
        // --- ARCHITEKTURA I HISTORIA ---
        {
            q: "Procesory Intel 8086 mogy zaadresowa pami o rozmiarze:",
            options: ["64 KiB", "1 MiB", "16 MiB", "4 GiB"],
            correct: 1,
            desc: "8086 posiada 20-bitow szyn adresow (2^20 = 1 MiB)."
        },
        {
            q: "Procesory Intel 8080 mogy zaadresowa pami o rozmiarze:",
            options: ["4 KiB", "16 KiB", "64 KiB", "1 MiB"],
            correct: 2,
            desc: "Intel 8080 by 8-bitowy z 16-bitow szyn adresow (2^16 = 65536 bajt贸w = 64 KiB)."
        },
        {
            q: "Ile bajt贸w miecia kolejka instrukcji procesora 8088?",
            options: ["4", "6", "8", "12"],
            correct: 0,
            desc: "8086 mia kolejk 6-bajtow, a 8088 (z w偶sz szyn danych) mia kolejk 4-bajtow."
        },
        {
            q: "Ile bitowe rejestry posiaday procesory Intel 4004?",
            options: ["4-bitowe", "8-bitowe", "16-bitowe", "32-bitowe"],
            correct: 0,
            desc: "Intel 4004 by pierwszym 4-bitowym mikroprocesorem."
        },
        {
            q: "Pierwszy mikroprocesor (1970r.) by opracowany do:",
            options: ["Kalkulatora", "Terminala komputerowego", "Samolotu F14", "Sterowania ramieniem"],
            correct: 0,
            desc: "Intel 4004 powsta na zam贸wienie firmy Busicom do kalkulatora."
        },
        {
            q: "Tryb chroniony po raz pierwszy Intel wprowadzi w procesorze:",
            options: ["80186", "80286", "80386", "Pentium"],
            correct: 1,
            desc: "80286 wprowadzi 16-bitowy tryb chroniony."
        },
        {
            q: "Wykonywanie spekulatywne po raz pierwszy Intel zastosowa w:",
            options: ["80486", "Pentium", "Pentium Pro", "Core 2 Duo"],
            correct: 2,
            desc: "Architektura P6 (Pentium Pro) wprowadzia wykonywanie Out-of-Order i spekulatywne."
        },
        {
            q: "Pierwszy procesor Intela wyposa偶ony w instrukcje AVX to:",
            options: ["Pentium 4", "Core 2 Duo", "Sandy Bridge", "Haswell"],
            correct: 2,
            desc: "AVX zadebiutowao w architekturze Sandy Bridge (2011)."
        },
        {
            q: "W procesorach Skylake Intel po raz pierwszy wprowadzi:",
            options: ["Rejestry 64-bitowe", "Dwa rodzaje rdzeni", "Instrukcje AVX-512", "Instrukcje SSE 4.2"],
            correct: 2,
            desc: "AVX-512 pojawio si w procesorach serwerowych Skylake-SP oraz w niekt贸rych wersjach desktop (HEDT)."
        },
        {
            q: "W procesorze Alder Lake Intel po raz pierwszy wprowadzi:",
            options: ["Rejestry 64-bitowe", "Piciostopniowy potok", "Dwa rodzaje rdzeni (big.LITTLE)", "Instrukcje AVX-512"],
            correct: 2,
            desc: "Architektura hybrydowa: P-cores (Performance) i E-cores (Efficient)."
        },
        {
            q: "Ile rejestr贸w ZMM posiadaj procesory Intel w trybie 64-bitowym?",
            options: ["8", "16", "32", "64"],
            correct: 2,
            desc: "AVX-512 rozszerza liczb rejestr贸w wektorowych do 32 (ZMM0-ZMM31)."
        },
        {
            q: "Rejestry MMX s czci:",
            options: ["Rejestr贸w XMM", "Rejestr贸w og贸lnego przeznaczenia", "Rejestr贸w koprocesora (FPU)", "Rejestr贸w segmentowych"],
            correct: 2,
            desc: "Rejestry MMX (MM0-MM7) s mapowane na rejestry stosu koprocesora (st0-st7), co uniemo偶liwia jednoczesne u偶ywanie FPU i MMX."
        },
        {
            q: "Superskalarno wynika z:",
            options: ["Wykonywania instrukcji w potoku", "Wykonywania kilku instrukcji jednoczenie (r贸wnolegle)", "Redukcji liczby rozkaz贸w", "Wykonywania spekulatywnego"],
            correct: 1,
            desc: "Superskalarno to zdolno procesora do wysyania wielu instrukcji do wielu jednostek wykonawczych w jednym cyklu zegara."
        },

        // --- ASEMBLER I INSTRUKCJE ---
        {
            q: "Kt贸ra instrukcja umo偶liwia operacj typu: 5*a + 13?",
            options: ["madd", "lea", "imul", "add"],
            correct: 1,
            desc: "LEA (Load Effective Address) pozwala na: baza + indeks*skala + przesunicie."
        },
        {
            q: "Kt贸ra z instrukcji umo偶liwia obliczenie modulo 16?",
            options: ["sar", "shr", "and", "div"],
            correct: 2,
            desc: "Modulo potgi 2 to operacja AND z mask (x % 16 == x & 15). 15 to 0Fh (00001111)."
        },
        {
            q: "Kt贸ra instrukcja umo偶liwia dzielenie przez 8 (z zachowaniem znaku)?",
            options: ["btc", "sbb", "sar", "shr"],
            correct: 2,
            desc: "SAR (Shift Arithmetic Right) przesuwa bity w prawo kopiujc bit znaku."
        },
        {
            q: "Do wyzerowania najmodszego bitu r贸wnego 1 su偶y instrukcja (BMI1):",
            options: ["popcnt", "lzcnt", "bextr", "blsr"],
            correct: 3,
            desc: "BLSR: Resetuje najni偶szy ustawiony bit."
        },
        {
            q: "Kt贸ra z instrukcji NIE korzysta z flag C, C2 i C0?",
            options: ["ficom", "fcom", "fxam", "fstsw"],
            correct: 2,
            desc: "FXAM (Examine) ustawia flagi C0-C3 w zale偶noci od typu liczby w ST(0), ale nie 'korzysta' z nich w sensie warunkowym jak skoki, tylko je ustawia."
        },
        {
            q: "Kt贸ra instrukcja zmienia flag ZF?",
            options: ["mov", "lea", "fucompp", "xchg"],
            correct: 2,
            desc: "Instrukcje przesania danych (MOV, LEA) zazwyczaj nie zmieniaj flag. Instrukcje por贸wnania (FUCOMPP - float) zmieniaj je."
        },
        {
            q: "Kt贸ra instrukcja NIE zmienia flagi Carry (CF)?",
            options: ["add", "sub", "dec", "neg"],
            correct: 2,
            desc: "INC i DEC modyfikuj flagi arytmetyczne (ZF, OF, SF), ale zachowuj CF."
        },
        {
            q: "Kt贸ra z instrukcji dla liczb ze znakiem przesya dla warunku 'mniejsze lub r贸wne'?",
            options: ["cmovb", "cmovle", "cmovl", "cmovna"],
            correct: 1,
            desc: "LE = Less or Equal (Signed). BE = Below or Equal (Unsigned)."
        },
        {
            q: "Kt贸ra instrukcja mo偶e zmieni rejestr CS?",
            options: ["mov", "pop", "lea", "jmp"],
            correct: 3,
            desc: "Rejestr CS (Code Segment) mo偶na zmieni tylko instrukcjami sterujcymi przepywem (jmp far, call far, ret, int)."
        },
        {
            q: "Przerwanie programowe wywouje instrukcja:",
            options: ["call", "int", "iret", "enter"],
            correct: 1,
            desc: "INT n - wywouje przerwanie programowe o numerze n."
        },
        {
            q: "Ile bajt贸w mieci si w rejestrze R8D?",
            options: ["1", "2", "4", "8"],
            correct: 2,
            desc: "R8 - 64 bity, R8D (Doubleword) - 32 bity = 4 bajty, R8W - 16 bit贸w, R8B - 8 bit贸w."
        },
        
        // --- SIMD / AVX ---
        {
            q: "Ile bajt贸w mieci si w rejestrze YMM?",
            options: ["16", "32", "64", "128"],
            correct: 1,
            desc: "YMM to 256 bit贸w = 32 bajty."
        },
        {
            q: "Ile podw贸jnych s贸w (DWORD, 32-bit) zawiera si w rejestrze YMM?",
            options: ["4", "8", "16", "32"],
            correct: 1,
            desc: "256 bit贸w / 32 bity = 8."
        },
        {
            q: "Do ilu bajt贸w wyr贸wnania adresu wymaga instrukcja 'vmovdqa ymm4, tablica'?",
            options: ["8", "16", "32", "64"],
            correct: 2,
            desc: "Koc贸wka 'a' (aligned) dla YMM wymaga wyr贸wnania 32-bajtowego."
        },
        {
            q: "Operacj przesania z niewyr贸wnanej pamici realizuje instrukcja AVX:",
            options: ["vmovdqa", "vmovdqu", "vmovaps", "vmaskmovdqu"],
            correct: 1,
            desc: "vmovdqu (UnAligned)."
        },
        {
            q: "Kt贸ra operacja konwertuje liczb cakowit na liczb pojedynczej precyzji?",
            options: ["vcvtsd2ss", "vcvtss2sd", "vcvtsi2ss", "vcvtss2si"],
            correct: 2,
            desc: "si (Signed Integer) -> 2 (to) -> ss (Scalar Single)."
        },
        {
            q: "Kt贸ra operacja konwertuje wektor double na wektor float?",
            options: ["vcvtsd2ss", "vcvtpd2ps", "vcvtps2pd", "vcvtsi2ss"],
            correct: 1,
            desc: "pd (Packed Double) -> ps (Packed Single)."
        },
        {
            q: "Instrukcja dodawania ssiednich liczb rzeczywistych podw贸jnej precyzji (Horizontal Add) to:",
            options: ["vaddpd", "vhaddpd", "vsumpd", "vmulpd"],
            correct: 1,
            desc: "HADD = Horizontal Add (dodaje np. a1+a2 i a3+a4)."
        },
        {
            q: "Operacj mieszania (blendowania) podw贸jnych s贸w z dw贸ch 藕r贸de realizuje:",
            options: ["vshufpd", "vpblendd", "vpackusdb", "vinsertf128"],
            correct: 1,
            desc: "vpblendd miesza dwordy (32-bit) wedug maski."
        },
        {
            q: "Instrukcja AVX obliczajca odwrotno pierwiastka ze SKALARA (single) to:",
            options: ["vsqrtss", "vrsqrtss", "vrsqrtps", "vdpps"],
            correct: 1,
            desc: "rsqrt (reciprocal sqrt) + ss (scalar single)."
        },
        {
            q: "Operacj wektorow AVX dla liczb podw贸jnej precyzji: v1 = -v1 + v2*v3 realizuje:",
            options: ["vfmadd132pd", "vfnmadd132pd", "vfmsub132pd", "vaddpd"],
            correct: 1,
            desc: "vFNmadd... (Fused Negative Multiply Add). Neguje wynik mno偶enia i dodaje (lub w tym przypadku: neguje skadnik dodawany)."
        },
        {
            q: "Prefix LOCK mo偶e odnosi si tylko do instrukcji, kt贸rych argument:",
            options: ["celu jest w pamici", "藕r贸da jest w pamici", "celu jest rejestrem", "jest natychmiastowy"],
            correct: 0,
            desc: "LOCK blokuje szyn pamici, wic ma sens tylko gdy zapisujemy do pamici (destination operand is memory)."
        },

        // --- ANALIZA KODU ---
        {
            q: "Jaki bdzie wynik w EAX? <br> mov eax, 0eca87531h <br> xor eax, 0f00ff00fh <br> shl eax, 0ch <br> bsr eax, eax",
            options: ["0eca78531h", "0a7853100h", "0000001fh", "00000001h"],
            correct: 2,
            desc: "BSR (Bit Scan Reverse) zwraca indeks najstarszego ustawionego bitu. Wynik to maa liczba (indeks 0-31)."
        },
        {
            q: "Jaki bdzie wynik w EAX? <br> mov eax, 87654321h <br> sar eax, 4 <br> btr eax, 1fh <br> xor eax, 0ff000033h",
            options: ["87765401h", "43b21901h", "0f8765401h", "88765432h"],
            correct: 0,
            desc: "1. sar zachowuje znak (F...), 2. btr zeruje bit 31 (F->7), 3. xor zmienia 7 na 8... Wynik: 87765401h."
        },
        {
            q: "W kt贸rym trybie adresowania warto argumentu nie jest pobierana z pamici danych?",
            options: ["Porednim-rejestrowym", "Natychmiastowym", "Bezporednim", "Indeksowym"],
            correct: 1,
            desc: "W trybie natychmiastowym (Immediate) warto jest zaszyta bezporednio w kodzie instrukcji, a nie w pamici danych."
        }
    ];

    let currentQuestionIndex = 0;
    let score = 0;
    const container = document.getElementById('quiz-container');
    const scoreSpan = document.getElementById('score');
    const currentQSpan = document.getElementById('currentQ');
    const totalQSpan = document.getElementById('totalQ');
    const finalScreen = document.getElementById('finalScreen');
    const scoreBox = document.getElementById('scoreBox');

    totalQSpan.innerText = questions.length;

    function renderQuestion(index) {
        container.innerHTML = '';
        const q = questions[index];
        
        const card = document.createElement('div');
        card.className = 'question-card active';

        const qText = document.createElement('div');
        qText.className = 'question-text';
        qText.innerHTML = (index + 1) + ". " + q.q;
        card.appendChild(qText);

        const optionsDiv = document.createElement('div');
        optionsDiv.className = 'options';

        q.options.forEach((opt, i) => {
            const btn = document.createElement('button');
            btn.className = 'option-btn';
            btn.innerHTML = opt;
            btn.onclick = () => checkAnswer(i, q.correct, btn, q.desc);
            optionsDiv.appendChild(btn);
        });

        card.appendChild(optionsDiv);

        const explanation = document.createElement('div');
        explanation.className = 'explanation';
        card.appendChild(explanation);

        const nextBtn = document.createElement('button');
        nextBtn.className = 'next-btn';
        nextBtn.innerText = index === questions.length - 1 ? "Zakocz Egzamin" : "Nastpne pytanie";
        nextBtn.onclick = () => nextQuestion();
        card.appendChild(nextBtn);

        container.appendChild(card);
    }

    function checkAnswer(selected, correct, btnElement, desc) {
        const buttons = document.querySelectorAll('.option-btn');
        buttons.forEach(b => b.disabled = true);

        const explDiv = document.querySelector('.explanation');
        explDiv.style.display = 'block';

        if (selected === correct) {
            btnElement.classList.add('correct');
            score++;
            scoreSpan.innerText = score;
            explDiv.innerHTML = "<strong>wietnie!</strong> " + desc;
            explDiv.style.borderColor = "#0f5132";
            explDiv.style.backgroundColor = "#d1e7dd";
        } else {
            btnElement.classList.add('incorrect');
            buttons[correct].classList.add('correct');
            explDiv.innerHTML = "<strong>Bd.</strong> " + desc;
            explDiv.style.borderColor = "#842029";
            explDiv.style.backgroundColor = "#f8d7da";
        }

        document.querySelector('.next-btn').style.display = 'inline-block';
    }

    function nextQuestion() {
        currentQuestionIndex++;
        if (currentQuestionIndex < questions.length) {
            currentQSpan.innerText = currentQuestionIndex + 1;
            renderQuestion(currentQuestionIndex);
        } else {
            showFinalScreen();
        }
    }

    function showFinalScreen() {
        scoreBox.style.display = 'none';
        container.style.display = 'none';
        finalScreen.style.display = 'block';
        
        const finalScoreSpan = document.getElementById('finalScore');
        finalScoreSpan.innerText = score;
        document.getElementById('finalTotal').innerText = questions.length;
        
        const percentage = (score / questions.length) * 100;
        const feedback = document.getElementById('feedbackText');
        
        if(percentage >= 90) {
            feedback.innerHTML = " <strong>Genialnie!</strong> Jeste gotowy na 5.0!";
            feedback.style.color = "#198754";
        } else if (percentage >= 50) {
            feedback.innerHTML = " <strong>Nie藕le.</strong> Ale powt贸rz materia.";
            feedback.style.color = "#fd7e14";
        } else {
            feedback.innerHTML = " <strong>Musisz jeszcze pocwiczy.</strong>";
            feedback.style.color = "#dc3545";
        }
    }

    // Start
    renderQuestion(0);

</script>

</body>
</html>
